/**
 * Created by 阿布 on 2016/2/1.
 */
/////////////////////////////////////////////////////////////
cmd- 先编译(带依赖jar包编译test.java 然后运行test.class)
javac -cp .;E:\test\lib\json.jar test.java
java test
/////////////////////////////////////////////////////////////
git - android studio教程 :http://my.oschina.net/u/2367628/blog/508283
git:
http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000
http://blog.csdn.net/god_wot/article/details/10522405
http://www.cnblogs.com/alanalan/archive/2012/09/17/2689747.html


本地文件夹创建版本库

git branch --set-upstream master origin/master

$ git init

本地文件的预加载 和 说明 和提交
$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m "add 3 files."

远程仓库创建与关联 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：
$ ssh-keygen -t rsa -C "youremail@example.com"
你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。
如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：
然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：

关联版本库
$ git remote add origin git@github.com:bulasuo/abuHttp.git

把远程厂库更新到此
$ git pull origin master

提交本地版本到远程版本库
$ git push -u origin master 或者 $ git push origin master

clone 远程版本库  到父目录clone到子目录(远程库)
$ git clone git@github.com:bulasuo/abuNote.git
Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快

已经有remote地址 可以
$ git remote rm origin清除

Git鼓励大量使用分支：
查看图线提交历史
git log --oneline --graph --decorate
查看分支：git branch
查看本地和远程分支：git branch -a
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name>
把远程分支checkout as new local branch
$ git checkout -b remote_branch origin/remote_branch

标签TAG:
命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id；
git tag -a <tagname> -m "blablabla..."可以指定标签信息；
git tag -s <tagname> -m "blablabla..."可以用PGP签名标签；
git tag可以查看所有标签。
git push origin <tagname>可以推送一个本地标签；
git push origin --tags可以推送全部未推送过的本地标签；
git tag -d <tagname>可以删除一个本地标签；
git push origin :refs/tags/<tagname>可以删除一个远程标签。
git checkout <tag>回退到tag的代码 但是要注意当前代码可能会丢失(切换到tag历史记录会处在分离头指针状态，这个是的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b tset v0.1.0  这个时候就会在分支上进行开发，之后可以切换到主线合并)

git版本回退
HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。

Please enter a commit message to explain why this merge is necessary.
请输入提交消息来解释为什么这种合并是必要的
1.按键盘字母 i 进入insert模式
2.修改最上面那行黄色合并信息,可以不修改
3.按键盘左上角"Esc"
4.输入":wq",注意是冒号+wq,按回车键即可

///////////////git 分支开发策略//////////////////////////////////////////////////////////////////////////
master作为主分支,
bug应该在master上修改 
并且master有变动后<比如在master上修改了bug>  要把master合并到 分支比如develop上
这样master和develop都会bug被修改了
如果在develop上又有一个分支develop_1 则master修改了bug后 应该把master和并到develop上,develop合并到develop_1上.
即(develop依赖master, develop_1依赖develop,而修改bug要从根源分支修改即master,并且修改完后 依次同步到子分支)
比如我这次开发的项目 我把email添加到了develop上 这是大错特错的 因为 我的本意是email肯定以后会和并到master 但是如果develop迟迟没用到  那么email也就迟迟和并不到master上了
所以我应该把email写在master上的  然后在和并master'到develop上的

///////////////算法的时间复杂度 和 空间复杂度//////////////////////////////////////////////////////////////////////////
时间复杂度:耗时递增-  常数阶-O(1); 次方阶-O(n^1);O(n^2):O(n^3)....; 指数阶-O(2^n)

====时间复杂度与执行指令数成正比  
**常数阶(没有参数n)
x=91; y=100;
while(y>0) if(x>100) {x=x-10;y--;} else x++;
解答： T(n)=O(1)，
**次方阶(参数n 的阶乘)
 x=1; 
for(i=1;i<=n;i++) 
        for(j=1;j<=i;j++)
           for(k=1;k<=j;k++)
               x++; 　
解答: T(n)=O(n^3)
**指数阶(参数n的值 表示算法的阶乘)

====空间复杂度与内存成正比
**空间复杂度O(1)，表示所需空间为常量，并且与n无关。
一般很少有次方阶 和 指数阶的  有的话说明方法写得很烂

///////////////java 反射机制//////////////////////////////////////////////////////////////////////////
getFields()获得某个类的所有的公共（public）的字段，包括父类。 
getDeclaredFields()获得某个类的所有申明的字段，即包括public、private和proteced，但是不包括父类的申明字段。 
同样类似的还有getConstructors()和getDeclaredConstructors()，getMethods()和getDeclaredMethods()。
**改变成员变量值
Class ownerClass = owner.getClass();  
Class ownerClass = Class.forName(className);  
Field field = sayClass.getDeclaredField("content");
ield.setAccessible(true);//跳过安全检验,防止是private权限 报错:java.lang.IllegalAccessException
field.set(say, "小公举");
**invoke方法
Method method = ownerClass.getMethod(methodName,argsClass);
method.invoke(owner, args);
**实例化对象
Class newoneClass = Class.forName(className);  
Constructor cons = newoneClass.getConstructor(argsClass);
 XX xx = cons.newInstance(args); 

///////////////android TextView的自动化填充//////////////////////////////////////////////////////////////////////////
<string name="age">王明今年 %1$d 岁</string>
然后设置的时候就可以：
textView.setText(String.format(mContext.getString(R.string.age), age));

///////////////android动画学习//////////////////////////////////////////////////////////////////////////
http://my.oschina.net/Bruce370/blog/493268
http://blog.csdn.net/feiduclear_up/article/details/45893619
http://blog.csdn.net/feiduclear_up/article/details/45915377
http://blog.csdn.net/lmj623565791/article/details/38067475
//rotationX:围绕X轴旋转
**ViewPropertyAnimator
ViewPropertyAnimator animator5 = imageView.animate();
        animator5.translationX(200).scaleX(2).setDuration(2000).start();
//位移动画
**package android.view.animation;
layFilter.clearAnimation();
Animation transIn = AnimationUtils.loadAnimation(getContext(), R.anim.anim_top_in_3s);
layFilter.startAnimation(transIn);
//X||Y||透明度缩放
**package android.animation;
AnimatorSet set = new AnimatorSet();
ObjectAnimator animatorA = ObjectAnimator.ofFloat(view, "alpha", 0.7f, 1f);
animatorA.setDuration(500);
ObjectAnimator rotationX = ObjectAnimator.ofFloat(view, "scaleX", 0.7f, 1.0f);
rotationX.setInterpolator(new AccelerateInterpolator());
rotationX.setDuration(500);
ObjectAnimator rotationY = ObjectAnimator.ofFloat(view, "scaleY", 0.7f, 1.0f);
rotationY.setInterpolator(new AccelerateInterpolator());
rotationY.setDuration(500);
set.playTogether(animatorA, rotationX, rotationY);
set.playTogether(animatorA);
set.start();
//旋转动画
ObjectAnimator rotation = ObjectAnimator.ofFloat(mRotationImv,"rotation", mRotation, mRotation +  60);
mRotation += 60;
rotation.setDuration(300);
rotation.setInterpolator(new DecelerateInterpolator());
rotation.start();
//Fragment的进入退出动画
FragmentTransaction.setCustomAnimations(R.anim.anim_right_in_3s, R.anim.anim_left_out_3s);

/////////////////////////////////////////////////////////////////////////////////////////

   /**
     * Enable extended support library window features.
     * <p>
     * This is a convenience for calling
     * {@link android.view.Window#requestFeature getWindow().requestFeature()}.
     * </p>
     *
     * @param featureId The desired feature as defined in
     * {@linkplain android.view.Window#requestFeature} or {@link android.support.v4.view.WindowCompat}.
     * @return Returns true if the requested feature is supported and now enabled.
     *
     * @see android.app.Activity#requestWindowFeature
     * @see android.view.Window#requestFeature
     */


android事件分发:
viewGroup的onInterceptTouchEvent（是否拦截）-子View的dispatchTouchEvent（是否消费）-onTouch（是否消费）-onTouchEvent（是否消费）-onClick

MVP M设计成单例  P设计成单例  V本身作为参数调用P  P回调V ；P本身作为参数调用M   M回调P  . 现有逻辑x ，1设计Mx处理x，2设计接口Ix 定义Mx回调的方法同时也是V要实现的接口，3Ix作为Mx处理x的方法的参数 ，4P本身实现Ix，本身作为参数调用Mx

一个activityattach了多个Fragment后,Fragment的onResume会随activity的onResume而触发 不管是不是isHidden;所以在Fragment的 onResume里如果弹出键盘 要判断是不是 ishidden;
而Fragment的show 和 hidden  不会触发 onResume 等生命周期 但会触发onHidden
所以在onHidden里调用onResume 基本可以实现 和activity一样的逻辑

数据加载重要逻辑原则:数据标志位的重要性 && NullPointException进行异常捕获(特别是不确定是数据,比如网络请求来的数据,一定要空指针异常捕获)
不显示数据到UI可以依据 1.数据为空 2.数据标志位为不显示
显示数据到UI 一定要是 1.数据不为空 且 2.数据标志位为显示
(就是说要显示到UI 一定要有标志位 为显示,仅仅依靠数据为不为null  可能数据的子数据为null,所以一定要对NullPointException进行异常捕获)

RecycleView的总结:
JsonObject.get("city_name")当该字段为null 它可能不为null 但是把它打印出来System.out.println(JsonObject.get("city_name"));结果是null 并且JsonObject.get("city_name").getAsString会报异常,所以这种应该尽量将JsonObject转换为Bean对象使用,或者在 onBindViewHolder(CoreViewHolder holder, int position) 最外面一层加个try{},不然的话一有异常RecycleView就会不正常具体表现是数据混乱,显示不正常.或者不要用JsonObject.get("city_name").getAsString而用JsonObject.get("city_name").toString.replace("\"", "");这里一定要注意 以后取值  要注意null空异常 或者在最外面加个try{}把业务上不应该为null的打印出来


泛型类的优势:
比如写了一个CallBack类是用泛型的,当用到改类的时候已经指定了类型参数,所以可以在该CallBack类里面对回调方法传的参数进行ClassCaseException异常捕获
而如果没有指定泛型,那就要在每个实现该回调方法的地方进行ClassCaseException异常捕获,这样非常繁琐.

ui 更新 不要调用 网络请求
网络请求 在 用户点击 或者 广播接收处 调用
每个网络请求  发送精确描述改 请求结果的 message.what
每个 广播接收处 要注册 改页面 需要接收的 精确描述的 message.what
页面数据放在arguments里 且中间的状态 也要 在此切换(尽量)
页面 :  数据放在argments;数据持久到本地?;数据恢复;
请求防刷要写在在网络底层ActionTimer
请求结果要过滤 再显示否?持久化否?
一个模型 比如user,逻辑写到user一个地方
页面编程等 要考虑 懒加载还是先加载
--逻辑之间,方法之间要注意解耦:
逻辑不能调逻辑 网络请求里不能调用其他网络请求,应该另写一个方法 另写一个逻辑再在这个逻辑里组合这些逻辑
即逻辑只能组合 而不能相互调用!!
"逻辑之间不要互相调用,只能组合它们形成新的逻辑,方法之间不要相互 调用方法 而是 组合方法形成新的方法"



清空连接证书  cmd: net use *  /del /y
然后 可以用的账号密码:  1.dev - 111  2.test - 111
其中前者权限大


1.根activity的back键要拦截并且重定义为Home键功能
public boolean onKeyDown(int keyCode, KeyEvent event) {
		 
	if(keyCode == KeyEvent.KEYCODE_BACK && event.getAction() ==KeyEvent.ACTION_DOWN) {
			this.startActivity(new Intent(Intent.ACTION_MAIN).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK).addCategory(Intent.CATEGORY_HOME));
			return true;
		}
		return super.onKeyDown(keyCode, event);
	}
2.需要重用的activity设为singleInstance 并且拦截他的 back键 重定义为要跳转到的activity
  
3.back键默认是要finish当前activity的
4.FLAG为FLAG_ACTIVITY_NEW_TASK的时候会查找是否与他本身有相同taskAffinity的task，如有则宿主到该task 否则 新建本身的taskAffinity 的task。
5.一个task为 home键右边任务栏的一个任务的选项卡（singleInstance除外），task之间可以互相叠加，重新排列
6.taskAffinity不设置则 一个application有一个task，所有activity都宿主到该task，task也有taskAffinity，默认值为根activity的taskAffinity，而根activity的taskAffinity默认为application的taskAffinity，application的taskAffinity未设置 则为 包名。
7.singleInstance的activity会新建task但是不会另建任务选项卡，现在模拟下面这种情况：
新建application，依次启动activity a、b、c 这时默认task堆栈《task是堆栈先进后出、队列是先进先出》为abc ,这时启动singleInstance 的activity d、 变成abcd 并且abc为默认task，d单独一个task，且该task有且仅有一个activity d。这时d startActivity 到 b， 这时会变成 dab《为什么会这样请看第5条》，d为一个task，ab为默认task，back键按2次会回到d， 但是你想想 a  activity是application的根activity通常是登入界面 或者 欢迎界面 而从a  back键后 居然回到 d！这会让用户感到奇怪。怎么处理？  看上面 第一条 重定义 a 的back键为home键 或者 a的back键 销毁所有。
///////////////////////////////////////////////////////////////////////////////////////////
/**
 * 1.activity创建view
 * 2.activity创建presenter<数据格式>(参数view)
 * 3.presenter在被创建的时候,即presenter的构造方法中持有了view,此时设置view持有本presenter,完成V-P的互相持有
 * 4.view要实现基view的多个方法,这里是 protected abstract int getContentViewLayoutID();//基view用来绑定布局文件
 * 和protected abstract void setViewCreated(@Nullable Bundle savedInstanceState);
 * //基view用来create view 并且要注意使用Bundle savedInstanceState恢复view
 * 5.view要实现基view(Interface)的多个方法,这里是 setProgressIndicator(boolean active)//被presenter在任务前回调
 * loadCompelete(Object O)//被presenter在任务完成时回调
 * loadError(int code, Exception e)//被presenter在任务出错时回调
 * setPresenter(BaseContract.Presenter presenter)//被view在创建时回调 用来持有一个presenter
 * 6.view 要重写android系统父view的onStart() 通过P启动task;  要重写android系统父view的onDestroyView() 销毁P
 * 7.Presenter 要实现基Presenter的多个方法 这里是  loadMore(boolean next)//被view在加载更多时回调
 * 和 start(Context appContext)//被view启动任务时回调
 * 和 destroy()//view被销毁时 回调销毁本presenter
 * 其他一些逻辑业务的方法  给view与用户交互时回调
 */


android获取当前activity UI线程利用反射 和代理 把 packageManage 成员变量 换成自定义的 代理
private void initPackageProx() {
        //获取ActivityThread实例
        Class<?> activityThreadClazz = null;
        Method currentActivityThreadMethod = null;
        try {
            activityThreadClazz = Class.forName("android.app.ActivityThread", false, getClassLoader());
            currentActivityThreadMethod = activityThreadClazz.getDeclaredMethod("currentActivityThread");
            Object activityThreadObject = null;
            activityThreadObject = currentActivityThreadMethod.invoke(null);
            //获得原始的IPackageManager
            Method getPackageManagerMethod = activityThreadClazz.getDeclaredMethod("getPackageManager");
            Object packageManager = getPackageManagerMethod.invoke(activityThreadObject);

            //生成我们的代理类
            Class<?> iPackageManagerClazz = Class.forName("android.content.pm.IPackageManager", false, getClassLoader());
            Object proxy = Proxy.newProxyInstance(getClassLoader(),
                    new Class[]{iPackageManagerClazz}, new PackageManagerProxy(this, packageManager,getUmChannel(this)));
            //把原先的IPackageManager替换掉
            Field packageManagerField = null;
            packageManagerField = activityThreadClazz.getDeclaredField("sPackageManager");
            packageManagerField.setAccessible(true);
            packageManagerField.set(activityThreadObject, proxy);

        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
    }

MVP进阶:
对象调用M
方法传递 都用对象做参数 并且该对象涉及到的逻辑的 引用都让该对象持有, 注意该对象只持有与数据 逻辑有关的东西 不持有view实例 或实例

ArrayList<ReceiptAddressBean> mReceiptAddressBeanList = new Gson().fromJson(response.get(Constant.Key.RESPONSE_OBJECTS).toString(),
                        new TypeToken<ArrayList<ReceiptAddressBean>>(){}.getType());