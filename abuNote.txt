




/////////////////////////////////////////////////////////////
git - android studio教程 :http://my.oschina.net/u/2367628/blog/508283
git:
本地文件夹创建版本库
$ git init

本地文件的预加载 和 说明 和提交
$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m "add 3 files."

远程仓库创建与关联 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：
$ ssh-keygen -t rsa -C "youremail@example.com"
你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。
如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：
然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：

关联版本库
$ git remote add origin git@github.com:bulasuo/abuHttp.git

把远程厂库更新到此
$ git pull origin master

提交本地版本到远程版本库
$ git push -u origin master 或者 $ git push origin master

clone 远程版本库  到父目录clone到子目录(远程库)
$ git clone git@github.com:bulasuo/abuNote.git

已经有remote地址 可以
$ git remote rm origin清除

/////////////////////////////////////////////////////////////////////////////////////////


android事件分发:
viewGroup的onInterceptTouchEvent（是否拦截）-子View的dispatchTouchEvent（是否消费）-onTouch（是否消费）-onTouchEvent（是否消费）-onClick

MVP M设计成单例  P设计成单例  V本身作为参数调用P  P回调V ；P本身作为参数调用M   M回调P  . 现有逻辑x ，1设计Mx处理x，2设计接口Ix 定义Mx回调的方法同时也是V要实现的接口，3Ix作为Mx处理x的方法的参数 ，4P本身实现Ix，本身作为参数调用Mx

一个activityattach了多个Fragment后,Fragment的onResume会随activity的onResume而触发 不管是不是isHidden;所以在Fragment的 onResume里如果弹出键盘 要判断是不是 ishidden;
而Fragment的show 和 hidden  不会触发 onResume 等生命周期 但会触发onHidden
所以在onHidden里调用onResume 基本可以实现 和activity一样的逻辑

泛型类的优势:
比如写了一个CallBack类是用泛型的,当用到改类的时候已经指定了类型参数,所以可以在该CallBack类里面对回调方法传的参数进行ClassCaseException异常捕获
而如果没有指定泛型,那就要在每个实现该回调方法的地方进行ClassCaseException异常捕获,这样非常繁琐.

ui 更新 不要调用 网络请求
网络请求 在 用户点击 或者 广播接收处 调用
每个网络请求  发送精确描述改 请求结果的 message.what
每个 广播接收处 要注册 改页面 需要接收的 精确描述的 message.what
页面数据放在arguments里 且中间的状态 也要 在此切换(尽量)
页面 :  数据放在argments;数据持久到本地?;数据恢复;
请求防刷要写在在网络底层ActionTimer
请求结果要过滤 再显示否?持久化否?
一个模型 比如user,逻辑写到user一个地方
页面编程等 要考虑 懒加载还是先加载
--逻辑之间,方法之间要注意解耦:
逻辑不能调逻辑 网络请求里不能调用其他网络请求,应该另写一个方法 另写一个逻辑再在这个逻辑里组合这些逻辑
即逻辑只能组合 而不能相互调用!!
"逻辑之间不要互相调用,只能组合它们形成新的逻辑,方法之间不要相互 调用方法 而是 组合方法形成新的方法"


清空连接证书  cmd: net use *  /del /y
然后 可以用的账号密码:  1.dev - 111  2.test - 111
其中前者权限大


1.根activity的back键要拦截并且重定义为Home键功能
public boolean onKeyDown(int keyCode, KeyEvent event) {
		 
	if(keyCode == KeyEvent.KEYCODE_BACK && event.getAction() ==KeyEvent.ACTION_DOWN) {
			this.startActivity(new Intent(Intent.ACTION_MAIN).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK).addCategory(Intent.CATEGORY_HOME));
			return true;
		}
		return super.onKeyDown(keyCode, event);
	}
2.需要重用的activity设为singleInstance 并且拦截他的 back键 重定义为要跳转到的activity
  
3.back键默认是要finish当前activity的
4.FLAG为FLAG_ACTIVITY_NEW_TASK的时候会查找是否与他本身有相同taskAffinity的task，如有则宿主到该task 否则 新建本身的taskAffinity 的task。
5.一个task为 home键右边任务栏的一个任务的选项卡（singleInstance除外），task之间可以互相叠加，重新排列
6.taskAffinity不设置则 一个application有一个task，所有activity都宿主到该task，task也有taskAffinity，默认值为根activity的taskAffinity，而根activity的taskAffinity默认为application的taskAffinity，application的taskAffinity未设置 则为 包名。
7.singleInstance的activity会新建task但是不会另建任务选项卡，现在模拟下面这种情况：
新建application，依次启动activity a、b、c 这时默认task堆栈《task是堆栈先进后出、队列是先进先出》为abc ,这时启动singleInstance 的activity d、 变成abcd 并且abc为默认task，d单独一个task，且该task有且仅有一个activity d。这时d startActivity 到 b， 这时会变成 dab《为什么会这样请看第5条》，d为一个task，ab为默认task，back键按2次会回到d， 但是你想想 a  activity是application的根activity通常是登入界面 或者 欢迎界面 而从a  back键后 居然回到 d！这会让用户感到奇怪。怎么处理？  看上面 第一条 重定义 a 的back键为home键 或者 a的back键 销毁所有。
///////////////////////////////////////////////////////////////////////////////////////////
/**
 * 1.activity创建view
 * 2.activity创建presenter<数据格式>(参数view)
 * 3.presenter在被创建的时候,即presenter的构造方法中持有了view,此时设置view持有本presenter,完成V-P的互相持有
 * 4.view要实现基view的多个方法,这里是 protected abstract int getContentViewLayoutID();//基view用来绑定布局文件
 * 和protected abstract void setViewCreated(@Nullable Bundle savedInstanceState);
 * //基view用来create view 并且要注意使用Bundle savedInstanceState恢复view
 * 5.view要实现基view(Interface)的多个方法,这里是 setProgressIndicator(boolean active)//被presenter在任务前回调
 * loadCompelete(Object O)//被presenter在任务完成时回调
 * loadError(int code, Exception e)//被presenter在任务出错时回调
 * setPresenter(BaseContract.Presenter presenter)//被view在创建时回调 用来持有一个presenter
 * 6.view 要重写android系统父view的onStart() 通过P启动task;  要重写android系统父view的onDestroyView() 销毁P
 * 7.Presenter 要实现基Presenter的多个方法 这里是  loadMore(boolean next)//被view在加载更多时回调
 * 和 start(Context appContext)//被view启动任务时回调
 * 和 destroy()//view被销毁时 回调销毁本presenter
 * 其他一些逻辑业务的方法  给view与用户交互时回调
 */


MVP进阶:
对象调用M
方法传递 都用对象做参数 并且该对象涉及到的逻辑的 引用都让该对象持有, 注意该对象只持有与数据 逻辑有关的东西 不持有view实例 或实例

ArrayList<ReceiptAddressBean> mReceiptAddressBeanList = new Gson().fromJson(response.get(Constant.Key.RESPONSE_OBJECTS).toString(),
                        new TypeToken<ArrayList<ReceiptAddressBean>>(){}.getType());